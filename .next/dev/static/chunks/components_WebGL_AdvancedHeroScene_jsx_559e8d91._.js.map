{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/rohitboni/Downloads/resume_project/portfolio/portfolio/components/WebGL/AdvancedHeroScene.jsx"],"sourcesContent":["// Paste the AdvancedHeroScene.jsx code from code.txt here (lines 1-401)\n\nimport React, { useRef, useEffect, useMemo } from 'react';\nimport * as THREE from 'three';\n\nconst AdvancedHeroScene = () => {\n  const containerRef = useRef(null);\n  const mouseRef = useRef({ x: 0.5, y: 0.5 });\n  const targetRotation = useRef({ x: 0, y: 0 });\n  \n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    const container = containerRef.current;\n    let { width, height } = container.getBoundingClientRect();\n    \n    // Detect mobile device\n    const isMobile = window.innerWidth < 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    const isLowEndDevice = isMobile && (navigator.hardwareConcurrency < 4 || navigator.deviceMemory < 4);\n    \n    // Scene\n    const scene = new THREE.Scene();\n    scene.fog = new THREE.FogExp2(0x080808, 0.015);\n    \n    // Camera - centered with better perspective\n    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);\n    camera.position.set(0, 0, 35);\n    camera.lookAt(0, 0, 0);\n    \n    // Add lighting to show cube structure better\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);\n    scene.add(ambientLight);\n    \n    const directionalLight1 = new THREE.DirectionalLight(0x8B5CF6, 0.6);\n    directionalLight1.position.set(5, 5, 5);\n    scene.add(directionalLight1);\n    \n    const directionalLight2 = new THREE.DirectionalLight(0x06B6D4, 0.5);\n    directionalLight2.position.set(-5, -5, 5);\n    scene.add(directionalLight2);\n    \n    const pointLight = new THREE.PointLight(0xffffff, 0.3, 100);\n    pointLight.position.set(0, 0, 10);\n    scene.add(pointLight);\n    \n    // Renderer\n    const renderer = new THREE.WebGLRenderer({\n      alpha: true,\n      antialias: !isLowEndDevice,\n      powerPreference: isMobile ? 'low-power' : 'high-performance',\n    });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\n    renderer.toneMappingExposure = 1.2;\n    container.appendChild(renderer.domElement);\n    \n    // === ROTATING CUBE (Central Element - Mouse Responsive) ===\n    const cubeSize = isMobile ? 7 : 10;\n    const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);\n    \n    // Add edge subdivision for better cube definition\n    const edges = new THREE.EdgesGeometry(cubeGeometry);\n    const edgeMaterial = new THREE.LineBasicMaterial({\n      color: 0xffffff,\n      transparent: true,\n      opacity: 0.4,\n      linewidth: 2,\n    });\n    const edgeLines = new THREE.LineSegments(edges, edgeMaterial);\n    \n    const cubeMaterial = new THREE.ShaderMaterial({\n      uniforms: {\n        uTime: { value: 0 },\n        uMouse: { value: new THREE.Vector2(0.5, 0.5) },\n        uColor1: { value: new THREE.Color('#8B5CF6') }, // Purple\n        uColor2: { value: new THREE.Color('#06B6D4') }, // Cyan\n        uColor3: { value: new THREE.Color('#10B981') }, // Green\n        uColor4: { value: new THREE.Color('#F59E0B') }, // Amber\n        uColor5: { value: new THREE.Color('#EF4444') }, // Red\n        uColor6: { value: new THREE.Color('#EC4899') }, // Pink\n      },\n      vertexShader: `\n        varying vec3 vPosition;\n        varying vec3 vNormal;\n        varying vec3 vWorldPosition;\n        varying vec2 vUv;\n        uniform float uTime;\n        uniform vec2 uMouse;\n        \n        void main() {\n          vPosition = position;\n          vNormal = normalize(normalMatrix * normal);\n          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n          vUv = uv;\n          \n          vec3 pos = position;\n          // Very subtle pulsing effect\n          float pulse = sin(uTime * 1.5) * 0.01 + 1.0;\n          pos *= pulse;\n          \n          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n        }\n      `,\n      fragmentShader: `\n        uniform float uTime;\n        uniform vec2 uMouse;\n        uniform vec3 uColor1;\n        uniform vec3 uColor2;\n        uniform vec3 uColor3;\n        uniform vec3 uColor4;\n        uniform vec3 uColor5;\n        uniform vec3 uColor6;\n        \n        varying vec3 vPosition;\n        varying vec3 vNormal;\n        varying vec3 vWorldPosition;\n        varying vec2 vUv;\n        \n        void main() {\n          // Calculate lighting for proper 3D appearance\n          vec3 viewDirection = normalize(cameraPosition - vWorldPosition);\n          vec3 lightDir1 = normalize(vec3(5.0, 5.0, 5.0));\n          vec3 lightDir2 = normalize(vec3(-5.0, -5.0, 5.0));\n          \n          // Diffuse lighting\n          float NdotL1 = max(dot(vNormal, lightDir1), 0.0);\n          float NdotL2 = max(dot(vNormal, lightDir2), 0.0);\n          float lighting = 0.4 + 0.6 * (NdotL1 * 0.6 + NdotL2 * 0.5);\n          \n          // Fresnel effect\n          float fresnel = pow(1.0 - max(dot(viewDirection, vNormal), 0.0), 2.0);\n          \n          // Smooth time-based color cycling through all luxury colors\n          // Slower transition speed for smoother changes\n          float colorCycle = mod(uTime * 0.12, 6.0);\n          \n          // Smooth interpolation using smoothstep (built-in GLSL function)\n          vec3 baseColor1, baseColor2, baseColor3;\n          float cycleProgress;\n          \n          if (colorCycle < 1.0) {\n            cycleProgress = smoothstep(0.0, 1.0, colorCycle);\n            baseColor1 = mix(uColor1, uColor2, cycleProgress);\n            baseColor2 = mix(uColor2, uColor3, cycleProgress * 0.6);\n            baseColor3 = mix(uColor3, uColor4, cycleProgress * 0.4);\n          } else if (colorCycle < 2.0) {\n            cycleProgress = smoothstep(0.0, 1.0, colorCycle - 1.0);\n            baseColor1 = mix(uColor2, uColor3, cycleProgress);\n            baseColor2 = mix(uColor3, uColor4, cycleProgress * 0.6);\n            baseColor3 = mix(uColor4, uColor5, cycleProgress * 0.4);\n          } else if (colorCycle < 3.0) {\n            cycleProgress = smoothstep(0.0, 1.0, colorCycle - 2.0);\n            baseColor1 = mix(uColor3, uColor4, cycleProgress);\n            baseColor2 = mix(uColor4, uColor5, cycleProgress * 0.6);\n            baseColor3 = mix(uColor5, uColor6, cycleProgress * 0.4);\n          } else if (colorCycle < 4.0) {\n            cycleProgress = smoothstep(0.0, 1.0, colorCycle - 3.0);\n            baseColor1 = mix(uColor4, uColor5, cycleProgress);\n            baseColor2 = mix(uColor5, uColor6, cycleProgress * 0.6);\n            baseColor3 = mix(uColor6, uColor1, cycleProgress * 0.4);\n          } else if (colorCycle < 5.0) {\n            cycleProgress = smoothstep(0.0, 1.0, colorCycle - 4.0);\n            baseColor1 = mix(uColor5, uColor6, cycleProgress);\n            baseColor2 = mix(uColor6, uColor1, cycleProgress * 0.6);\n            baseColor3 = mix(uColor1, uColor2, cycleProgress * 0.4);\n          } else {\n            cycleProgress = smoothstep(0.0, 1.0, colorCycle - 5.0);\n            baseColor1 = mix(uColor6, uColor1, cycleProgress);\n            baseColor2 = mix(uColor1, uColor2, cycleProgress * 0.6);\n            baseColor3 = mix(uColor2, uColor3, cycleProgress * 0.4);\n          }\n          \n          // Mouse-influenced gradient with smooth position-based variation\n          float mouseInfluenceX = (uMouse.x - 0.5) * 1.2;\n          float mouseInfluenceY = (uMouse.y - 0.5) * 1.2;\n          \n          // Slower, smoother gradients\n          float t = sin(vPosition.x * 0.1 + uTime * 0.4 + mouseInfluenceX * 1.5) * 0.5 + 0.5;\n          float t2 = cos(vPosition.y * 0.1 + uTime * 0.35 + mouseInfluenceY * 1.5) * 0.5 + 0.5;\n          float t3 = sin(vPosition.z * 0.1 + uTime * 0.38) * 0.5 + 0.5;\n          \n          // Smooth multi-color mixing with eased transitions\n          vec3 color = mix(baseColor1, baseColor2, smoothstep(0.0, 1.0, t));\n          color = mix(color, baseColor3, smoothstep(0.0, 1.0, t2) * 0.5);\n          color = mix(color, baseColor1, smoothstep(0.0, 1.0, t3) * 0.3);\n          \n          // Apply lighting to show cube faces properly\n          color *= lighting;\n          \n          // Add fresnel glow with smooth color variation\n          color += fresnel * baseColor2 * 0.4;\n          \n          // Edge glow with smooth luxury shimmer (subtle)\n          float edge = 1.0 - abs(dot(viewDirection, vNormal));\n          color += edge * baseColor3 * 0.3;\n          \n          // Subtle sparkle effect\n          float sparkle = sin(vPosition.x * 1.2 + uTime * 1.5) * sin(vPosition.y * 1.2 + uTime * 1.4) * sin(vPosition.z * 1.2 + uTime * 1.45);\n          color += sparkle * 0.05 * baseColor1;\n          \n          // Make cube fully opaque (no transparency)\n          float alpha = 1.0;\n          \n          gl_FragColor = vec4(color, alpha);\n        }\n      `,\n      transparent: false,\n      side: THREE.FrontSide,\n      depthWrite: true,\n      wireframe: false,\n    });\n    \n    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);\n    cube.position.set(0, 0, 0);\n    scene.add(cube);\n    \n    // Add edge lines to clearly show cube structure\n    edgeLines.position.set(0, 0, 0);\n    scene.add(edgeLines);\n    \n    // Wireframe cube for extra detail (subtle)\n    const wireframeCube = new THREE.LineSegments(\n      new THREE.WireframeGeometry(cubeGeometry),\n      new THREE.LineBasicMaterial({\n        color: 0xffffff,\n        transparent: true,\n        opacity: 0.15,\n      })\n    );\n    wireframeCube.position.set(0, 0, 0);\n    scene.add(wireframeCube);\n    \n    // === WIREFRAME ICOSAHEDRON (Background decoration) ===\n    const icoGeometry = new THREE.IcosahedronGeometry(12, 1);\n    const icoWireframe = new THREE.WireframeGeometry(icoGeometry);\n    const icoMaterial = new THREE.LineBasicMaterial({\n      color: 0x8B5CF6,\n      transparent: true,\n      opacity: 0.2,\n    });\n    const icoLines = new THREE.LineSegments(icoWireframe, icoMaterial);\n    icoLines.position.set(0, 0, -15);\n    scene.add(icoLines);\n    \n    // === FLOATING GEOMETRIC SHAPES ===\n    const shapes = [];\n    const shapeGeometries = [\n      new THREE.OctahedronGeometry(2),\n      new THREE.TetrahedronGeometry(2.5),\n      new THREE.IcosahedronGeometry(1.8),\n      new THREE.DodecahedronGeometry(2),\n    ];\n    \n    const shapeCount = isMobile ? (isLowEndDevice ? 8 : 12) : 20;\n    for (let i = 0; i < shapeCount; i++) {\n      const geometry = shapeGeometries[i % shapeGeometries.length];\n      const material = new THREE.MeshBasicMaterial({\n        color: i % 3 === 0 ? 0x8B5CF6 : i % 3 === 1 ? 0x06B6D4 : 0x10B981,\n        wireframe: true,\n        transparent: true,\n        opacity: 0.4 + Math.random() * 0.3,\n      });\n      \n      const mesh = new THREE.Mesh(geometry, material);\n      mesh.position.set(\n        (Math.random() - 0.5) * 80,\n        (Math.random() - 0.5) * 50,\n        (Math.random() - 0.5) * 30 - 10\n      );\n      mesh.rotation.set(\n        Math.random() * Math.PI,\n        Math.random() * Math.PI,\n        Math.random() * Math.PI\n      );\n      mesh.userData = {\n        rotationSpeed: {\n          x: (Math.random() - 0.5) * 0.02,\n          y: (Math.random() - 0.5) * 0.02,\n          z: (Math.random() - 0.5) * 0.02,\n        },\n        floatSpeed: 0.5 + Math.random() * 1,\n        floatOffset: Math.random() * Math.PI * 2,\n        originalY: mesh.position.y,\n      };\n      \n      shapes.push(mesh);\n      scene.add(mesh);\n    }\n    \n    // === PARTICLE GALAXY ===\n    const galaxyCount = isMobile ? (isLowEndDevice ? 1000 : 1500) : 3000;\n    const galaxyGeometry = new THREE.BufferGeometry();\n    const galaxyPositions = new Float32Array(galaxyCount * 3);\n    const galaxyColors = new Float32Array(galaxyCount * 3);\n    const galaxySizes = new Float32Array(galaxyCount);\n    \n    const colorInside = new THREE.Color('#8B5CF6');\n    const colorOutside = new THREE.Color('#06B6D4');\n    \n    for (let i = 0; i < galaxyCount; i++) {\n      const i3 = i * 3;\n      const radius = Math.random() * 50 + 5;\n      const spinAngle = radius * 0.5;\n      const branchAngle = ((i % 3) / 3) * Math.PI * 2;\n      \n      const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 5;\n      const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 5;\n      const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * 5;\n      \n      galaxyPositions[i3] = Math.cos(branchAngle + spinAngle) * radius + randomX;\n      galaxyPositions[i3 + 1] = randomY;\n      galaxyPositions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ - 15;\n      \n      const mixedColor = colorInside.clone();\n      mixedColor.lerp(colorOutside, radius / 55);\n      \n      galaxyColors[i3] = mixedColor.r;\n      galaxyColors[i3 + 1] = mixedColor.g;\n      galaxyColors[i3 + 2] = mixedColor.b;\n      \n      galaxySizes[i] = Math.random() * 2 + 0.5;\n    }\n    \n    galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(galaxyPositions, 3));\n    galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(galaxyColors, 3));\n    galaxyGeometry.setAttribute('size', new THREE.BufferAttribute(galaxySizes, 1));\n    \n    const galaxyMaterial = new THREE.ShaderMaterial({\n      uniforms: {\n        uTime: { value: 0 },\n        uPixelRatio: { value: renderer.getPixelRatio() },\n      },\n      vertexShader: `\n        attribute float size;\n        varying vec3 vColor;\n        uniform float uTime;\n        uniform float uPixelRatio;\n        \n        void main() {\n          vColor = color;\n          vec3 pos = position;\n          \n          float angle = uTime * 0.1;\n          float s = sin(angle);\n          float c = cos(angle);\n          pos.xz = mat2(c, -s, s, c) * pos.xz;\n          \n          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n          gl_PointSize = size * uPixelRatio * (30.0 / -mvPosition.z);\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      `,\n      fragmentShader: `\n        varying vec3 vColor;\n        \n        void main() {\n          float d = length(gl_PointCoord - 0.5);\n          if (d > 0.5) discard;\n          \n          float alpha = 1.0 - smoothstep(0.0, 0.5, d);\n          alpha *= 0.8;\n          \n          gl_FragColor = vec4(vColor, alpha);\n        }\n      `,\n      transparent: true,\n      depthWrite: false,\n      blending: THREE.AdditiveBlending,\n      vertexColors: true,\n    });\n    \n    const galaxy = new THREE.Points(galaxyGeometry, galaxyMaterial);\n    galaxy.position.set(0, 0, -10);\n    scene.add(galaxy);\n    \n    // === FLOATING LIGHT ORBS ===\n    const orbGroup = new THREE.Group();\n    const orbCount = isMobile ? 4 : 8;\n    for (let i = 0; i < orbCount; i++) {\n      const orbGeometry = new THREE.SphereGeometry(0.5, 16, 16);\n      const orbMaterial = new THREE.MeshBasicMaterial({\n        color: i % 2 === 0 ? 0x8B5CF6 : 0x06B6D4,\n        transparent: true,\n        opacity: 0.8,\n      });\n      const orb = new THREE.Mesh(orbGeometry, orbMaterial);\n      \n      const angle = (i / orbCount) * Math.PI * 2;\n      const radius = 15;\n      orb.position.set(\n        Math.cos(angle) * radius,\n        Math.sin(angle) * 3,\n        Math.sin(angle) * radius\n      );\n      orb.userData = { angle, radius, speed: 0.3 + Math.random() * 0.2 };\n      orbGroup.add(orb);\n    }\n    scene.add(orbGroup);\n    \n    // === MOUSE/TOUCH HANDLING ===\n    const handleMouseMove = (e) => {\n      const rect = container.getBoundingClientRect();\n      mouseRef.current.x = (e.clientX - rect.left) / width;\n      mouseRef.current.y = 1 - (e.clientY - rect.top) / height;\n      // More responsive rotation\n      targetRotation.current.y = (mouseRef.current.x - 0.5) * 1.2;\n      targetRotation.current.x = (mouseRef.current.y - 0.5) * 1.0;\n    };\n    \n    const handleTouchMove = (e) => {\n      if (e.touches.length > 0) {\n        const rect = container.getBoundingClientRect();\n        const touch = e.touches[0];\n        mouseRef.current.x = (touch.clientX - rect.left) / width;\n        mouseRef.current.y = 1 - (touch.clientY - rect.top) / height;\n        targetRotation.current.y = (mouseRef.current.x - 0.5) * 0.8;\n        targetRotation.current.x = (mouseRef.current.y - 0.5) * 0.6;\n      }\n    };\n    \n    window.addEventListener('mousemove', handleMouseMove);\n    window.addEventListener('touchmove', handleTouchMove, { passive: true });\n    \n    // === ANIMATION LOOP ===\n    let animationId;\n    const clock = new THREE.Clock();\n    \n    const animate = () => {\n      animationId = requestAnimationFrame(animate);\n      const elapsed = clock.getElapsedTime();\n      \n      // Update uniforms\n      cubeMaterial.uniforms.uTime.value = elapsed;\n      cubeMaterial.uniforms.uMouse.value.set(mouseRef.current.x, mouseRef.current.y);\n      galaxyMaterial.uniforms.uTime.value = elapsed;\n      \n      // Rotate cube 360 degrees continuously with mouse influence\n      cube.rotation.x = elapsed * 0.5 + targetRotation.current.x * 0.8;\n      cube.rotation.y = elapsed * 0.6 + targetRotation.current.y * 0.8;\n      cube.rotation.z = elapsed * 0.4;\n      \n      // Ensure full 360 degree rotation\n      if (cube.rotation.x >= Math.PI * 2) cube.rotation.x -= Math.PI * 2;\n      if (cube.rotation.y >= Math.PI * 2) cube.rotation.y -= Math.PI * 2;\n      if (cube.rotation.z >= Math.PI * 2) cube.rotation.z -= Math.PI * 2;\n      \n      // Sync edge lines and wireframe cube rotation\n      edgeLines.rotation.copy(cube.rotation);\n      wireframeCube.rotation.copy(cube.rotation);\n      \n      // Animate wireframe color with smooth transitions\n      const wireframeMaterial = wireframeCube.material;\n      const color1 = new THREE.Color(0x8B5CF6); // Purple\n      const color2 = new THREE.Color(0x06B6D4); // Cyan\n      const color3 = new THREE.Color(0x10B981); // Green\n      const color4 = new THREE.Color(0xF59E0B); // Amber\n      const color5 = new THREE.Color(0xEF4444); // Red\n      const color6 = new THREE.Color(0xEC4899); // Pink\n      \n      // Smooth easing function\n      const smoothStep = (t) => t * t * (3 - 2 * t);\n      \n      let wireframeColor = new THREE.Color();\n      const cycle = (elapsed * 0.15) % 6;\n      const progress = cycle % 1;\n      const smoothProgress = smoothStep(progress);\n      \n      if (cycle < 1) {\n        wireframeColor.lerpColors(color1, color2, smoothProgress);\n      } else if (cycle < 2) {\n        wireframeColor.lerpColors(color2, color3, smoothProgress);\n      } else if (cycle < 3) {\n        wireframeColor.lerpColors(color3, color4, smoothProgress);\n      } else if (cycle < 4) {\n        wireframeColor.lerpColors(color4, color5, smoothProgress);\n      } else if (cycle < 5) {\n        wireframeColor.lerpColors(color5, color6, smoothProgress);\n      } else {\n        wireframeColor.lerpColors(color6, color1, smoothProgress);\n      }\n      \n      wireframeMaterial.color.copy(wireframeColor);\n      \n      // Rotate icosahedron\n      icoLines.rotation.x = elapsed * 0.1;\n      icoLines.rotation.y = elapsed * 0.15;\n      \n      // Animate floating shapes\n      shapes.forEach((shape) => {\n        const { rotationSpeed, floatSpeed, floatOffset, originalY } = shape.userData;\n        shape.rotation.x += rotationSpeed.x;\n        shape.rotation.y += rotationSpeed.y;\n        shape.rotation.z += rotationSpeed.z;\n        shape.position.y = originalY + Math.sin(elapsed * floatSpeed + floatOffset) * 2;\n      });\n      \n      // Animate orbs around center\n      orbGroup.children.forEach((orb, i) => {\n        const { angle, radius, speed } = orb.userData;\n        orb.position.x = Math.cos(angle + elapsed * speed) * radius;\n        orb.position.z = Math.sin(angle + elapsed * speed) * radius;\n        orb.position.y = Math.sin(elapsed * 2 + i) * 3;\n      });\n      \n      // Camera follow mouse (subtle movement)\n      camera.position.x += (targetRotation.current.y * 5 - camera.position.x) * 0.02;\n      camera.position.y += (targetRotation.current.x * 5 - camera.position.y) * 0.02;\n      camera.lookAt(0, 0, 0);\n      \n      renderer.render(scene, camera);\n    };\n    animate();\n    \n    // === RESIZE ===\n    const handleResize = () => {\n      const { width: w, height: h } = container.getBoundingClientRect();\n      width = w;\n      height = h;\n      camera.aspect = w / h;\n      camera.updateProjectionMatrix();\n      renderer.setSize(w, h);\n    };\n    window.addEventListener('resize', handleResize);\n    \n    return () => {\n      window.removeEventListener('mousemove', handleMouseMove);\n      window.removeEventListener('touchmove', handleTouchMove);\n      window.removeEventListener('resize', handleResize);\n      cancelAnimationFrame(animationId);\n      if (container.contains(renderer.domElement)) {\n        container.removeChild(renderer.domElement);\n      }\n      renderer.dispose();\n    };\n  }, []);\n  \n  return (\n    <div\n      ref={containerRef}\n      style={{\n        position: 'absolute',\n        inset: 0,\n        zIndex: 0,\n        pointerEvents: 'none',\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n      }}\n    />\n  );\n};\n\nexport default AdvancedHeroScene;"],"names":[],"mappings":"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"}}]
}